# 寻找一种易于理解的一致性算法

## 摘要

Raft是一种为了管理复制日志的一致性算法。它提供了和Paxos算法相同的功能和性能，但是它的算法结构和Paxos不同，使得Raft算法更加容易理解并且更容易构建实际的系统。为了提升可理解性，Raft将一致性算法分解成了几个关键模块，例如选主、日志复制和安全性。同时它通过实施一个更强的一致性来减少需要考虑的状态的数量。从一个用户研究的结果可以证明，对于学生而言，Raft算法比Paxos算法更加容易学习。Raft算法还包括一个新的机制来允许集群成员的动态改变，它利用重叠的大多数来保证安全性。

## 1 介绍

一致性算法允许一组机器像一个整体一样工作，即使其中一些机器出现故障也能够工作下去。正因为如此，一致性算法在构建可信赖的大规模软件系统中扮演着重要的角色。在过去的10年里，Paxos算法统治着一致性算法这一领域：绝大多数的实现都是基于Paxos或者受其影响。同时Paxos也成为了教学领域里讲解一致性问题时的示例。

但是不幸的是，尽管有很多工作都在尝试降低它的复杂性，但是Paxos算法依然十分难以理解。并且，Paxos自身的算法结构需要进行大幅的修改才能够应用到实际的系统中。这些都导致了工业界和学术界都对Paxos算法感到十分头疼。

和Paxos算法进行过努力之后，我们开始寻找一种新的一致性算法，可以为构建实际的系统和教学提供更好的基础。我们的做法是不寻常的，我们的首要目标是可理解性：我们是否可以在实际系统中定义一个一致性算法，并且能够比Paxos算法以一种更加容易的方式来学习。此外，我们希望该算法方便系统构建者的直觉的发展。不仅一个算法能够工作很重要，而且能够显而易见的知道为什么能工作也很重要。

Raft一致性算法就是这些工作的结果。在设计Raft算法的时候，我们使用一些特别的技巧来提升它的可理解性，包括算法分解（Raft主要被分成了选主，日志复制和安全三个模块）和减少状态机的状态（相对于Paxos，Raft减少了非确定性和服务器互相处于非一致性的方式）。一份针对在两所大学43个学生的研究表明Raft明显比Paxos算法更加容易理解。在这些学生同时学习了这两种算法之后，和Paxos比起来，其中33个学生能够回答有关于Raft的问题。

Raft算法在许多方面和现有的一致性算法都很相似（主要是Oki和Liskov的Viewstamped Replication），但是它也有一些独特的特性：

* **强领导者**：和其他一致性算法相比，Raft使用一种更强的领导能力形式。比如，日志项只从领导者发送给其他的服务器。这种方式简化了对复制日志的管理并且使得Raft算法更加易于理解。
* **领导选举**：Raft算法使用一个随机计时器来选举领导者。这种方式只在任何一致性算法都必须实现的心跳机制上增加了一点机制。在解决冲突的时候会更加简单快捷。
* **关系调整**：<!-- 这儿需要仔细考察一下 -->

我们相信，Raft算法不论出于教学目的还是作为实践项目的基础都是要比Paxos或者其他一致性算法要优异的。它比其他算法更加简单，更见容易理解；它的算法描述足以实现一个现实的系统；它有好多开源的实现并且在很多公司里使用；它的安全性已经被证明；它的效率和其他算法比起来也不相上下。

接下来，这篇论文会介绍以下内容：复制状态机问题（第 2 节），讨论Paxos的优点和缺点（第 3 节），讨论我们为了理解能力而使用的方法（第 4 节），阐述Raft一致性算法（第 5-8 节），评价Raft算法（第 9 节），以及一些相关的工作（第 10 节）。

## 2 复制状态机

一致性算法是从复制状态机的背景下提出的。在这种方法中，一组服务器上的状态机产生相同状态的副本，并且在一些机器宕掉的情况下也可以继续运行。复制状态机在分布式系统中被用于解决很多容忍错误的问题。例如，大规模的系统中通常都有一个集群领导者，像GFS、HDFS和RAMCloud，十分典型的使用一个单独的复制状态机去管理领导选举和存储配置信息并且在领导人宕机的情况下也要存活下来。比如Chubby和ZooKeeper。

<!-- 图片1待补充 -->

复制状态机通常都是基于复制日志实现的，如图1。每一个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。每一个日志都按照相同的顺序包含相同的指令，所以每一个服务器都执行相同的指令序列。因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。

保证复制日志相同就是一致性算法的工作了。在一台服务器上，一致性模块接收客户端发送来的指令然后增加到自己的日志中去。它和其他服务器上的一致性模块进行通信来保证每一个服务器上的日志最终都已相同的顺序包含相同的请求，尽管有些服务器会宕机。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成一个高可靠的状态机。

实际系统中使用的一致性算法通常含有以下特性：

* 安全性保证（绝对不会返回一个错误的结果）：在非拜占庭错误情况下，包括网络延迟、分区、丢包、冗余和乱序等错误都可以保证正确。
* 可用性：集群中只要有大多数的机器可运行并且能够相互通信、和客户端通信，就可以保证可用。因此，一个典型的包含5个节点的集群可以容忍两个节点的失败。服务器被停止就认为是失败。他们当有稳定的存储的时候可以从状态中恢复回来并重新加入集群。
* 不依赖时序来保证一致性：物理时钟错误或者极端的消息延迟在可能只有在最坏情况下才会导致可用性问题。
* 通常情况下，一条指令可以尽可能快的在集群中大多数节点响应一轮远程过程调用时完成。小部分比较慢的节点不会影响系统整体的性能。

## 3 Paxos算法的问题

在过去的10年里，Leslie Lamport的Paxos算法几乎已经成为一致性的代名词：Paxos是在课程教学中最经常使用的算法，同时也是大多数一致性算法实现的起点。Paxos首先定义了一个能够达成单一决策一致的协议，比如单条的复制日志项。我们把这一子集叫做单决策Paxos。然后通过组合多个Paxos协议的实例来促进一系列决策的达成。Paxos保证安全性和活性，同时也支持集群成员关系的变更。Paxos的正确性已经被证明，在通常情况下也很高效。

不幸的是，Paxos有两个明显的缺点。第一个缺点是Paxos算法特别的难以理解。完整的解释是出了名的不透明；通过极大的努力之后，也只有少数人成功理解了这个算法。因此，有了几次用更简单的术语来解释Paxos的尝试。尽管这些解释都只关注了单决策的子集问题，但依然很具有挑战性。在2012年NSDI的会议中的一次调查显示，很少有人对Paxos算法感到满意，甚至在经验老道的研究者中也是如此。我们自己也尝试去理解Paxos；我们一直没能理解Paxos直到我们读了很多对Paxos的简化解释并且设计了我们自己的算法，这一过程花了近一年时间。

我们假设Paxos的不透明性来自它选择单决策问题作为它的基础。单决策Paxos是晦涩微妙的，它被划分成了两种没有简单直观解释和无法独立理解的情景。因此，这导致了很难建立起直观的感受为什么单决策Paxos算法能够工作。构成多决策Paxos增加了很多错综复杂的规则。我们相信，在多决策上达成一致性的问题（一份日志而不是单一的日志记录）能够被分解成其他的方式并且更加直接和明显。

Paxos算法的第二个问题就是它没有提供一个足够好的用来构建一个现实系统的基础。一个原因是还没有一种被广泛相互认同的多决策问题的算法。Lamport的描述基本上都是关于单决策Paxos的；他简要描述了实施多决策Paxos的方法，但是缺乏很多细节。当然也有很多具体化Paxos的尝试，但是他们都互相不一样，和Paxos的概述也不同。例如Chubby这样的系统实现了一个类似于Paxos的算法，但是大多数的细节并没有被公开。

而且，Paxos算法的结构也不是十分易于构建实践的系统；单决策分解也会产生其他的结果。例如，独立的选择一组日志项然后合并成一个序列化的日志并没有带来太多的好处，仅仅增加了不少复杂性。围绕着日志来设计一个系统是更加简单高效的；新日志项以严格限制的顺序增添到日志中去。另一个问题是，Paxos使用了一种对等的点对点的方式作为它的核心（尽管它最终提议了一种弱领导人的方法来优化性能）。在只有一个决策会被制定的简化世界中是很有意义的，但是很少有现实的系统使用这种方式。如果有一系列的决策需要被制定，首先选择一个领导人，然后让他去协调所有的决议，会更加简单快速。

因此，实际的系统中很少有和Paxos相似的实践。每一种实现都是从Paxos开始研究，然后发现很多实现上的难题，再然后开发了一种和Paxos明显不一样的结构。这样非常费时和容易出错的，并且理解Paxos的难度是的这个问题更加糟糕。Paxos算法在理论上被证明是正确可行的，但是现实的系统和Paxos差别是如此的大，以至于这些证明没有什么太大的价值。下面来自Chubby实现非常典型：

> 在Paxos算法描述和实现现实系统中间有者巨大的鸿沟。最终的系统建立在一种没有经过证明的算法之上。

由于以上问题，我们认为Paxos算法既没有提供一个良好的基础给实践的系统，也没有给教学很好的帮助。基于一致性问题在大规模软件系统中的重要性，我们决定看看我们是否可以设计一个拥有更好特性的替代Paxos的一致性算法。Raft算法就是这次实验的结果。

## 4 为了可理解性的设计

设计Raft算法我们有几个初衷：它必须提供一个完整的实际的系统实现基础，这样才能大大减少开发者的工作；它必须在任何情况下都是安全的并且在大多数的情况下都是可用的；并且它的大部分操作必须是高效的。但是我们最重要也是最大的挑战是可理解性。它必须保证对于普遍的人群都可以十分舒适容易的去理解。另外，它必须能够让人形成直观的认识，这样系统的构建者才能够在现实中进行必然的扩展。

在设计Raft算法的时候，有很多的点需要我们在各种备选方案中进行选择。在这种情况下，我们评估备选方案基于可理解性原则：解释各个备选方案有多大的难度（例如，Raft的状态空间有多复杂，是否有微妙的暗示）？对于一个读者而言，完全理解这个方案和暗示是否容易？

我们意识到对这种可理解性分析上具有高度的主观性；尽管如此，我们使用了两种通常适用的技术来解决这个问题。第一个技术就是众所周知的问题分解：只要有可能，我们就将问题分解成几个相对独立的，可被解决的、可解释的和可理解的子问题。例如，Raft算法被我们分成领导人选举，日志复制，安全性和角色改变几个部分。

我们使用的第二个方法是通过减少状态的数量来简化需要考虑的状态空间，使的系统更加连贯并且在可能的时候消除不确定性。特别的，所有的日志是不允许有空洞的，并且Raft限制了日志之间变成不一致状态的可能。尽管在大多数情况下我们都试图去消除不确定性，但是也有一些情况下不确定性可以提升可理解性。尤其是，随机方法增加了不确定性，但是他们易于减少状态空间数量通过处理所有可能选择时使用相似的方法。我们使用随机化去简化Raft中领导人选举算法。

## 5 Raft一致性算法

Raft是一种用来管理章节 2 中描述的复制日志的算法。图 2 为了参考总结了这个算法的简略版本，图 3 列举了这个算法的一些关键特性。图中的这些元素会在剩下的章节逐一介绍。

Raft通过选举一个高贵的领导人，然后给予他全部的管理复制日志的责任来实现一致性。领导人从客户端接收日志项，把日志项复制到其他服务器上，并且当保证安全性的时候告诉其他的服务器应用日志项到他们的状态机中。拥有一个领导人大大简化了对复制日志的管理。例如，领导人可以决定新的日志项需要放在日志中的什么位置而不需要和其他服务器商议，并且数据都从领导人流向其他服务器。一个领导人可以宕机可以和其他服务器失去连接，这时一个新的领导人会被选举出来。

通过领导人的方式，Raft将一致性问题分解成了三个相对独立的子问题，这些问题会在接下来的子章节中进行讨论：

* **领导选举**：一个新的领导人需要被选举出来当先存的领导人宕机的时候（章节 5.2）
* **日志复制**：领导人必须从客户端接收日志然后复制到集群中的其他节点，并且强制要求其他节点的日志保持和自己相同。
* **安全性**：在Raft中安全性的关键实在图 3 中展示的状态机安全：如果有任何的服务器节点已经应用了一个确定的日志项到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一个不同的指令。章节 5.4 阐述了Raft算法是如何保证这个特性的；这个解决方案涉及到一个额外的选举机制（5.2 节）上的限制。

在展示一致性算法之后，这一章节会讨论可用性的一些问题和系统中的候选人角色的问题。

<!-- 图 2 待补充 -->

<!-- 图 3 待补充 -->

### 5.1 Raft基础

一个Raft集群包含若干个服务器节点；通常是 5 个，这允许整个系统容忍 2 个节点的失效。在任何时刻，每一个服务器节点都处于这三个状态之一：领导人、跟随者或者候选人。在通常情况下，系统中只有一个领导人并且其他的节点全部都是跟随者。跟随者都是被动的：他们不会发送任何请求，只是简单的响应来自领导者或者候选人的请求。领导人处理所有的客户端请求（如果一个客户端和跟随者联系，那么跟随者会把请求重定向给领导人）。第三种状态，候选人，是用来在 5.2 节描述的选举新领导人时使用。图 4 展示了这些状态和他们之前转换关系；这些转换关系会在接下来进行讨论。

Raft把时间分割成任意长度的**任期**，如图 5。任期用连续的整数标记。每一端任期从一次**选举**开始，就像章节 5.2 描述的一样，一个或者多个候选人尝试成为领导者。如果一个候选人赢得选举，然后他就在接下来的任期内充当领导人的职责。在某些情况下，一次选举过程会造成选票的瓜分。在这种情况下，这一任期会以没有领导人结束；一个新的任期（和一次新的选举）会很快重新开始。Raft保证了在一个给定的任期内，最多只有一个领导者。

不同的服务器节点可能多次观察到任期之间的转换，但在某些情况下，一个节点也可能观察不到任何一次选举或者整个任期全程。任期在Raft算法中充当逻辑时钟的作用，这会允许服务器节点查明一些过期的信息比如陈旧的领导者。每一个节点存储一个当前任期号，这一编号在整个时期内单调的增长。当服务器之间通信的时候回交换当前任期号；如果一个服务器的当前任期号比其他人小，那么他会更新自己的编号到较大的编号值。如果一个候选人或者领导者发现自己的任期号过期了，那么他会立即恢复成跟随者状态。如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求。

Raft算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的RPCs。投票请求（RequestVote） RPCs 由候选人在选举期间发起（章节  5.2），然后附加条目(AppendEntries) RPCs 由领导人发起用来复制日志和提供一种心跳机制的形式（章节 5.3）。第 7 节增加了第三种 RPC 为了在服务器之间传输快照。当服务器没有及时的收到 RPC 的响应时，会进行重试， 并且他们能够并行的发起 RPCs 来活的最佳的性能。
